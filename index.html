<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>SplitSmart - House Expenses</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
    body { font-family: 'Inter', sans-serif; }
    .modal-enter { animation: zoomIn 0.18s ease-out; }
    @keyframes zoomIn { from { opacity:0; transform:scale(0.98);} to {opacity:1; transform:scale(1);} }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #f1f5f9; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
  </style>
</head>

<body class="bg-slate-50 text-slate-900">
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import {
      getAuth, signInWithPopup, GoogleAuthProvider,
      onAuthStateChanged, signOut
    } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-auth.js";
    import {
      getFirestore,
      collection, doc, addDoc, setDoc, updateDoc, deleteDoc,
      onSnapshot, query, where, orderBy, serverTimestamp,
      arrayUnion, arrayRemove, getDoc, getDocs, limit
    } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";

    // =========================
    // 1) Firebase config (public)
    // =========================
    // NOTE: This config cannot be hidden in a public website. Protect with rules + domain restrictions.
    const firebaseConfig = {
      apiKey: "AIzaSyAg5PYPLSBIOlIwTypFkNf8BRGgnIS3FXY",
      authDomain: "splitsmart-889da.firebaseapp.com",
      projectId: "splitsmart-889da",
      storageBucket: "splitsmart-889da.firebasestorage.app",
      messagingSenderId: "265383787810",
      appId: "1:265383787810:web:de28c8f28ce1fd9a9bf97b",
      measurementId: "G-ZN3B2YLXVT"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const { useEffect, useMemo, useState } = React;

    // =========================
    // 2) UI constants
    // =========================
    const Icons = {
      food: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2M7 2v20M21 15V2a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3Zm0 0v7"></path></svg>,
      construction: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="m22 2-8 4-10 12L2 22l4-2 12-10L22 2Z"></path></svg>,
      car: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 13.1V16c0 .6.4 1 1 1h2"></path><circle cx="7" cy="17" r="2"></circle><circle cx="17" cy="17" r="2"></circle></svg>,
      rent: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>,
      receipt: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><rect width="16" height="20" x="4" y="2" rx="2"></rect><line x1="8" x2="16" y1="6" y2="6"></line><line x1="8" x2="16" y1="10" y2="10"></line><line x1="8" x2="12" y1="14" y2="14"></line></svg>,
      userPlus: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><line x1="19" x2="19" y1="8" y2="14"></line><line x1="16" x2="22" y1="11" y2="11"></line></svg>,
      plus: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><line x1="12" x2="12" y1="5" y2="19"></line><line x1="5" x2="19" y1="12" y2="12"></line></svg>,
      settle: <svg fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>
    };

    const CATEGORIES = [
      { id: 'food', name: 'Food', icon: 'food' },
      { id: 'construction', name: 'Home Construction', icon: 'construction' },
      { id: 'car', name: 'Car', icon: 'car' },
      { id: 'rent', name: 'Rent', icon: 'rent' },
      { id: 'other', name: 'Other', icon: 'receipt' },
    ];

    // =========================
    // 3) Helpers (money + math)
    // =========================
    const toCents = (val) => {
      const n = Number(val);
      if (!Number.isFinite(n)) return 0;
      return Math.round(n * 100);
    };
    const toDollars = (cents) => (cents / 100);

    function distributeRounding(amountCents, owedMapCents, percentages) {
      // owedMapCents: {uid: cents} already rounded
      // Ensure sum == amountCents by distributing remainder
      const sum = Object.values(owedMapCents).reduce((a,b)=>a+b,0);
      let remainder = amountCents - sum;
      if (remainder === 0) return owedMapCents;

      // pick uid to receive remainder: highest percentage (stable)
      const entries = Object.entries(percentages || {});
      entries.sort((a,b) => (b[1] ?? 0) - (a[1] ?? 0));
      const targetUid = entries[0]?.[0] || Object.keys(owedMapCents)[0];

      const fixed = { ...owedMapCents };
      fixed[targetUid] = (fixed[targetUid] || 0) + remainder;
      return fixed;
    }

    function computeNetBalances(members, transactions) {
      // netCents: + means user is owed, - means user owes
      const net = {};
      members.forEach(m => { net[m.uid] = 0; });

      for (const tx of transactions) {
        if (tx.type === 'PAYMENT') {
          // from paid to -> from net increases, to net decreases
          const amt = tx.amountCents || 0;
          if (net[tx.fromUserId] !== undefined) net[tx.fromUserId] += amt;
          if (net[tx.toUserId] !== undefined) net[tx.toUserId] -= amt;
          continue;
        }

        // EXPENSE
        const amountCents = tx.amountCents || 0;
        const paidBy = tx.paidByUserId;
        const participants = Array.isArray(tx.participants) ? tx.participants : [];

        if (net[paidBy] !== undefined) net[paidBy] += amountCents;

        if (tx.splitType === 'PERCENTAGE') {
          const percentages = tx.percentages || {};
          let owed = {};
          for (const uid of participants) {
            const pct = Number(percentages[uid] || 0);
            const cents = Math.round(amountCents * (pct / 100));
            owed[uid] = cents;
          }
          owed = distributeRounding(amountCents, owed, percentages);
          for (const uid of participants) {
            if (net[uid] !== undefined) net[uid] -= (owed[uid] || 0);
          }
        } else {
          // EQUAL
          const count = participants.length || 0;
          if (count > 0) {
            const base = Math.floor(amountCents / count);
            let rem = amountCents - base * count;
            // distribute remainder cents to first participants
            for (let i = 0; i < participants.length; i++) {
              const uid = participants[i];
              const owe = base + (rem > 0 ? 1 : 0);
              if (rem > 0) rem -= 1;
              if (net[uid] !== undefined) net[uid] -= owe;
            }
          }
        }
      }
      return net;
    }

    function simplifyDebts(net) {
      // net: {uid: cents}, + is creditor, - is debtor
      const creditors = [];
      const debtors = [];
      for (const [uid, amt] of Object.entries(net)) {
        if (amt > 0) creditors.push([uid, amt]);
        else if (amt < 0) debtors.push([uid, -amt]); // store positive owed
      }
      creditors.sort((a,b) => b[1]-a[1]);
      debtors.sort((a,b) => b[1]-a[1]);

      const transfers = [];
      let i = 0, j = 0;
      while (i < debtors.length && j < creditors.length) {
        const [duid, damt] = debtors[i];
        const [cuid, camt] = creditors[j];
        const pay = Math.min(damt, camt);
        transfers.push({ fromUserId: duid, toUserId: cuid, amountCents: pay });
        debtors[i][1] -= pay;
        creditors[j][1] -= pay;
        if (debtors[i][1] === 0) i++;
        if (creditors[j][1] === 0) j++;
      }
      return transfers;
    }

    // =========================
    // 4) App
    // =========================
    function App() {
      const [user, setUser] = useState(null);
      const [loading, setLoading] = useState(true);
      const [errorMessage, setErrorMessage] = useState(null);

      const [groups, setGroups] = useState([]);
      const [activeGroupId, setActiveGroupId] = useState(null);

      const [members, setMembers] = useState([]);
      const [transactions, setTransactions] = useState([]); // expenses + payments

      const [pendingInvites, setPendingInvites] = useState([]);

      const [newGroupName, setNewGroupName] = useState("");

      const [showInviteModal, setShowInviteModal] = useState(false);
      const [inviteEmail, setInviteEmail] = useState("");

      const [showAddExpense, setShowAddExpense] = useState(false);
      const [showRecordPayment, setShowRecordPayment] = useState(false);

      // Expense form state
      const [splitType, setSplitType] = useState("PERCENTAGE"); // PERCENTAGE or EQUAL
      const [payerUid, setPayerUid] = useState("");
      const [selectedParticipants, setSelectedParticipants] = useState({});
      const [percentages, setPercentages] = useState({}); // {uid: number}

      // Payment form state
      const [paymentFrom, setPaymentFrom] = useState("");
      const [paymentTo, setPaymentTo] = useState("");

      // -------- Auth --------
      useEffect(() => {
        const unsub = onAuthStateChanged(auth, async (u) => {
          setUser(u || null);
          setLoading(false);
          setErrorMessage(null);

          if (u) {
            // create/update user profile doc
            try {
              await setDoc(doc(db, "users", u.uid), {
                displayName: u.displayName || "User",
                email: (u.email || "").toLowerCase(),
                photoURL: u.photoURL || null,
                updatedAt: serverTimestamp(),
                createdAt: serverTimestamp()
